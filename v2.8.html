<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三维点云/模型可视化器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        #container, #preprocess-preview-container { width: 100%; height: 100%; display: block; }
        .panel { transition: all 0.3s ease-in-out; background-color: rgba(42, 50, 65, 0.8); backdrop-filter: blur(5px); }
        #progress-bar { transition: width 0.2s ease-out; }
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #4a5568; border-radius: 5px; outline: none; opacity: 0.7; transition: opacity .2s; }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #4299e1; cursor: pointer; border-radius: 50%; }
        .btn-active { background-color: #3b82f6 !important; color: white !important; }
        #preprocess-modal-content { max-height: 85vh; }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="container" class="absolute top-0 left-0 w-full h-full"></div>
    
    <div id="progress-container" class="hidden absolute top-0 left-0 w-full h-full bg-gray-900 bg-opacity-75 flex-col justify-center items-center z-50 pointer-events-auto">
        <div class="w-11/12 md:w-1/2 max-w-lg bg-gray-700 rounded-full h-4 mb-4 overflow-hidden">
            <div id="progress-bar" class="bg-blue-600 h-4 rounded-full" style="width: 0%"></div>
        </div>
        <p id="progress-text" class="text-white text-lg font-semibold">正在加载...</p>
    </div>

    <!-- 预处理模态窗口 -->
    <div id="preprocess-modal" class="hidden absolute top-0 left-0 w-full h-full bg-gray-900 bg-opacity-80 flex justify-center items-center z-40 pointer-events-auto">
        <div id="preprocess-modal-content" class="bg-gray-800 rounded-lg shadow-2xl w-11/12 max-w-6xl flex flex-col overflow-hidden">
            <div class="p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold">数据预处理</h2>
                <p class="text-sm text-gray-400">请为文件的每一列数据指定正确的含义 (X, Y, Z, R, G, B)。</p>
            </div>
            <div class="flex-grow flex flex-col md:flex-row overflow-y-auto">
                <div class="w-full md:w-1/2 p-4 overflow-y-auto">
                    <h3 class="font-semibold mb-2">列映射设置</h3>
                    <div id="column-mapping-container" class="space-y-2"></div>
                </div>
                <div class="w-full md:w-1/2 p-4 border-t md:border-t-0 md:border-l border-gray-700 flex flex-col">
                    <h3 class="font-semibold mb-2">实时预览</h3>
                    <div id="preprocess-preview-container" class="flex-grow bg-gray-900 rounded-md relative min-h-[200px] md:min-h-0"></div>
                </div>
            </div>
            <div class="p-4 border-t border-gray-700 flex justify-end space-x-4">
                <button id="preprocess-undo-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg">撤销</button>
                <button id="preprocess-close-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">关闭</button>
                <button id="preprocess-apply-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">应用并可视化</button>
            </div>
        </div>
    </div>

    <!-- 主UI -->
    <div class="absolute top-0 left-0 w-full h-full p-4 md:p-6 flex flex-col pointer-events-none">
        <header class="flex justify-between items-center">
            <div>
                <h1 class="text-xl md:text-2xl font-bold text-white/90">三维点云/模型可视化器</h1>
                <p class="text-xs text-gray-400/50">Developed by Yan Tan * Github:@Archer0083</p>
            </div>
            <div class="flex items-center space-x-4 pointer-events-auto">
                <button id="close-model-btn" class="hidden bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">关闭模型</button>
                <label for="file-input" class="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">上传文件</label>
                <input type="file" id="file-input" class="hidden" accept=".txt,.xyz,.obj,.ply,.mtl,.jpg,.jpeg,.png" multiple>
            </div>
        </header>
        <div id="info-panel" class="panel absolute bottom-4 left-4 p-4 rounded-lg shadow-lg max-w-xs pointer-events-auto"><h2 class="font-bold text-lg mb-2 border-b border-gray-600 pb-1">操作指南</h2><ul class="text-sm space-y-1 text-gray-300"><li><strong class="text-white">拾取点:</strong> (指针模式下) 单击左键</li><li><strong class="text-white">旋转:</strong> 按住鼠标左键拖动</li><li><strong class="text-white">缩放:</strong> 滚动鼠标滚轮</li><li><strong class="text-white">平移:</strong> 按住鼠标右键拖动</li></ul><div class="mt-2 pt-2 border-t border-gray-600 text-xs"><p class="text-gray-300">支持格式: .txt, .xyz, .obj, .ply</p></div><div id="model-info" class="mt-3 pt-2 border-t border-gray-600 text-xs text-gray-400"></div></div>
        <div id="picking-info-panel" class="panel absolute bottom-4 right-4 p-4 rounded-lg shadow-lg max-w-xs pointer-events-auto hidden"><h2 class="font-bold text-lg mb-2 border-b border-gray-600 pb-1">坐标信息</h2><div id="picking-data" class="text-sm space-y-1 text-gray-300"></div></div>
        <div id="controls-panel" class="panel absolute top-20 right-4 p-4 rounded-lg shadow-lg max-w-xs w-full pointer-events-auto"><h2 class="font-bold text-lg mb-3 border-b border-gray-600 pb-1">显示控制</h2><div class="space-y-4"><div><label class="block text-sm font-medium mb-1">交互模式</label><div class="flex space-x-2"><button id="mode-pointer-btn" title="指针模式 (用于拾取)" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded flex justify-center items-center"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg></button><button id="mode-hand-btn" title="手指模式 (用于导航)" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded flex justify-center items-center"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6l-2-2-2.5 2.5-1.5-1.5L8 8.5 4 5 2 7l3 3.5-2 2L5.5 15 8 13l2 2 .5.5 2 2 1.5-1.5L18 11z"/></svg></button></div></div><div><label id="point-size-label" for="point-size-slider" class="block text-sm font-medium mb-1">点大小</label><input id="point-size-slider" type="range" min="0.001" max="0.2" step="0.001" value="0.05"></div><div><label for="opacity-slider" class="block text-sm font-medium mb-1">透明度</label><input id="opacity-slider" type="range" min="0" max="1" step="0.01" value="1"></div><div><label class="block text-sm font-medium mb-1">背景</label><div class="flex space-x-2"><button id="bg-dark-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-1 px-3 rounded">深色</button><button id="bg-light-btn" class="w-full bg-gray-400 hover:bg-gray-300 text-black font-semibold py-1 px-3 rounded">浅色</button></div></div></div></div>
    </div>

    <script type="importmap">{"imports": {"three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"}}</script>

    <script type="module">
        /*
         * 三维点云/模型可视化器 (3D Point Cloud / Model Visualizer)
         * 版本 (Version): 2.8
         * 开发者 (Developer): Yan Tan * Github:@Archer0083
         * 描述 (Description): 一个基于 Three.js 的Web应用，用于加载、预处理和可视化多种三维点云和模型文件。
         */
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        // --- 全局变量 ---
        let scene, camera, renderer, controls, currentObject, raycaster, mouse, pickedPointMarker;
        let interactionMode = 'picking';
        let preprocessScene, preprocessCamera, preprocessRenderer, preprocessControls, preprocessPoints;
        let originalFileContent, currentFileName, columnMappings, mappingHistory;

        // --- DOM 元素 ---
        const DOM = {
            container: document.getElementById('container'), fileInput: document.getElementById('file-input'),
            modelInfo: document.getElementById('model-info'), pickingInfoPanel: document.getElementById('picking-info-panel'),
            pickingData: document.getElementById('picking-data'), pointSizeSlider: document.getElementById('point-size-slider'),
            opacitySlider: document.getElementById('opacity-slider'), bgDarkBtn: document.getElementById('bg-dark-btn'),
            bgLightBtn: document.getElementById('bg-light-btn'), pointSizeLabel: document.getElementById('point-size-label'),
            closeModelBtn: document.getElementById('close-model-btn'), modePointerBtn: document.getElementById('mode-pointer-btn'),
            modeHandBtn: document.getElementById('mode-hand-btn'), progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'), progressText: document.getElementById('progress-text'),
            preprocessModal: document.getElementById('preprocess-modal'), columnMappingContainer: document.getElementById('column-mapping-container'),
            preprocessPreviewContainer: document.getElementById('preprocess-preview-container'), preprocessUndoBtn: document.getElementById('preprocess-undo-btn'),
            preprocessCloseBtn: document.getElementById('preprocess-close-btn'), preprocessApplyBtn: document.getElementById('preprocess-apply-btn'),
        };

        // --- 动画循环 ---
        function animateMainScene() { requestAnimationFrame(animateMainScene); controls.update(); renderer.render(scene, camera); }
        function animatePreprocessScene() { if (preprocessScene) { requestAnimationFrame(animatePreprocessScene); preprocessControls.update(); preprocessRenderer.render(preprocessScene, preprocessCamera); } }

        // --- UI & 控制函数 ---
        function showProgress(text = "正在加载...") { DOM.progressText.textContent = text; DOM.progressBar.style.width = '0%'; DOM.progressContainer.classList.remove('hidden'); DOM.progressContainer.classList.add('flex'); }
        function updateProgressBar(percent, text) { DOM.progressBar.style.width = `${percent}%`; if (text) { DOM.progressText.textContent = text; } }
        function hideProgress() { DOM.progressContainer.classList.add('hidden'); DOM.progressContainer.classList.remove('flex'); }
        function handlePointSizeChange(event) { if (currentObject && currentObject.isPoints) { currentObject.material.size = parseFloat(event.target.value); } }
        function handleOpacityChange(event) { const opacity = parseFloat(event.target.value); if (currentObject) { currentObject.traverse(child => { if (child.material) { const materials = Array.isArray(child.material) ? child.material : [child.material]; materials.forEach(material => { material.transparent = opacity < 1; material.opacity = opacity; material.needsUpdate = true; }); } }); } }
        function setBackgroundTheme(theme) { if (theme === 'dark') { scene.background.set(0x111827); } else { scene.background.set(0xf3f4f6); } }
        function setInteractionMode(mode) { interactionMode = mode; if (mode === 'picking') { DOM.modePointerBtn.classList.add('btn-active'); DOM.modeHandBtn.classList.remove('btn-active'); DOM.container.style.cursor = 'crosshair'; } else { DOM.modePointerBtn.classList.remove('btn-active'); DOM.modeHandBtn.classList.add('btn-active'); DOM.container.style.cursor = 'grab'; } controls.enabled = true; }
        
        function closeCurrentModel() { 
            if (currentObject) { 
                scene.remove(currentObject); 
                currentObject.traverse(child => { 
                    if (child.geometry) child.geometry.dispose(); 
                    if (child.material) { 
                        if (Array.isArray(child.material)) { 
                            child.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); }); 
                        } else { 
                            if(child.material.map) child.material.map.dispose(); 
                            child.material.dispose(); 
                        } 
                    } 
                }); 
                currentObject = null; 
            } 
            DOM.closeModelBtn.classList.add('hidden'); 
            DOM.modelInfo.innerHTML = ''; 
            DOM.pickingInfoPanel.classList.add('hidden'); 
            pickedPointMarker.visible = false; 
        }

        function displayLoadedObject(object, sourceName, transform = null) { 
            closeCurrentModel();
            currentObject = object; 
            if (transform) {
                currentObject.userData.transform = transform;
            }
            currentObject.traverse(child => { if (child.isMesh) { child.geometry.computeVertexNormals(); } });
            scene.add(currentObject); 
            DOM.closeModelBtn.classList.remove('hidden');
            const isPoints = object.isPoints || (object.isGroup && object.children.some(c => c.isPoints));
            DOM.pointSizeSlider.disabled = !isPoints;
            DOM.pointSizeLabel.classList.toggle('text-gray-500', !isPoints);
            if (isPoints && object.material) DOM.pointSizeSlider.value = object.material.size;
            DOM.opacitySlider.value = 1;
            handleOpacityChange({ target: DOM.opacitySlider }); 
            let totalVertices = 0;
            object.traverse(child => { if(child.isMesh || child.isPoints) { totalVertices += child.geometry.attributes.position.count; }}); 
            DOM.modelInfo.innerHTML = `<p><strong>来源:</strong> ${sourceName}</p><p><strong>顶点/点数:</strong> ${totalVertices.toLocaleString()}</p>`; 
            const box = new THREE.Box3().setFromObject(object); 
            const center = box.getCenter(new THREE.Vector3()); 
            const size = box.getSize(new THREE.Vector3()); 
            const maxDim = Math.max(size.x, size.y, size.z); 
            controls.target.copy(center); 
            const distance = (maxDim > 0 ? maxDim : 10) / 2 / Math.tan(Math.PI * camera.fov / 360); 
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize(); 
            camera.position.copy(direction.multiplyScalar(distance * 1.5).add(center)); 
            controls.update(); 
        }

        // --- 预处理逻辑 (已修复) ---
        function showPreprocessModal(fileContent, fileName) {
            originalFileContent = fileContent;
            currentFileName = fileName;
            mappingHistory = [];
            const lines = fileContent.split('\n').filter(line => line.trim() !== '' && !isNaN(line.trim().split(/\s+/)[0])).slice(0, 20);
            if (lines.length === 0) { alert("文件中未找到可预览的数字数据。"); hideProgress(); return; }
            const numColumns = lines[0].trim().split(/\s+/).length;
            columnMappings = Array(numColumns).fill('ignore');
            const defaultMappings = ['x', 'y', 'z', 'r', 'g', 'b'];
            for (let i = 0; i < Math.min(numColumns, defaultMappings.length); i++) { columnMappings[i] = defaultMappings[i]; }
            saveMappingState();
            DOM.columnMappingContainer.innerHTML = '';
            for (let i = 0; i < numColumns; i++) {
                const row = document.createElement('div');
                row.className = 'flex items-center space-x-2 p-1 bg-gray-700 rounded';
                row.innerHTML = `<span class="font-mono text-sm w-1/3 truncate" title="${lines[0].trim().split(/\s+/)[i]}">列 ${i + 1}</span><select data-col-index="${i}" class="column-select bg-gray-600 text-white rounded p-1 w-2/3"><option value="ignore">忽略</option><option value="x">X (经度)</option><option value="y">Y (纬度)</option><option value="z">Z (高程)</option><option value="r">R</option><option value="g">G</option><option value="b">B</option></select>`;
                DOM.columnMappingContainer.appendChild(row);
                const select = row.querySelector('select');
                select.value = columnMappings[i];
                select.addEventListener('change', onMappingChange);
            }
            DOM.preprocessModal.classList.remove('hidden');
            DOM.preprocessModal.classList.add('flex');
            if (!preprocessScene) {
                preprocessScene = new THREE.Scene();
                preprocessScene.background = new THREE.Color(0x2d3748);
                const { width, height } = DOM.preprocessPreviewContainer.getBoundingClientRect();
                preprocessCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                preprocessCamera.position.set(1, 1, 1);
                preprocessRenderer = new THREE.WebGLRenderer({ antialias: true });
                preprocessRenderer.setSize(width, height);
                DOM.preprocessPreviewContainer.innerHTML = '';
                DOM.preprocessPreviewContainer.appendChild(preprocessRenderer.domElement);
                preprocessControls = new OrbitControls(preprocessCamera, preprocessRenderer.domElement);
                preprocessControls.enableDamping = true;
                preprocessScene.add(new THREE.AxesHelper(1));
                animatePreprocessScene();
            }
            updatePreprocessPreview();
            hideProgress();
        }

        function onMappingChange(event) {
            saveMappingState();
            const select = event.target;
            columnMappings[parseInt(select.dataset.colIndex)] = select.value;
            updatePreprocessPreview();
        }
        
        function updatePreprocessPreview() {
            const { vertices, colors } = parseDataWithMappings(originalFileContent.split('\n').slice(0, 500).join('\n'), columnMappings);
            if (preprocessPoints) { preprocessScene.remove(preprocessPoints); preprocessPoints.geometry.dispose(); preprocessPoints.material.dispose(); }
            if (vertices.length === 0) return;
            
            const { transformedVertices } = transformToLocalMeters(vertices);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(transformedVertices, 3));
            if (colors.length > 0) geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: colors.length > 0 });
            if (colors.length === 0) material.color.set(0x00aaff);
            preprocessPoints = new THREE.Points(geometry, material);
            preprocessScene.add(preprocessPoints);
            geometry.computeBoundingSphere();
            preprocessControls.target.copy(geometry.boundingSphere.center);
            const dist = geometry.boundingSphere.radius / Math.tan(Math.PI * preprocessCamera.fov / 360);
            preprocessCamera.position.copy(preprocessControls.target).add(new THREE.Vector3(0, 0, dist * 1.5 || 2));
            preprocessControls.update();
        }

        function parseDataWithMappings(content, mappings) {
            const vertices = [], colors = [];
            const hasColor = mappings.some(m => ['r','g','b'].includes(m));
            for (const line of content.split('\n')) {
                const parts = line.trim().split(/\s+/);
                if (parts.length < mappings.length) continue;
                let x=0, y=0, z=0, r=1, g=1, b=1, isValid = true;
                for (let i = 0; i < mappings.length; i++) {
                    const val = parseFloat(parts[i]);
                    if (isNaN(val)) { isValid = false; break; }
                    switch (mappings[i]) {
                        case 'x': x = val; break; case 'y': y = val; break; case 'z': z = val; break;
                        case 'r': r = val > 1 ? val / 255 : val; break; case 'g': g = val > 1 ? val / 255 : val; break; case 'b': b = val > 1 ? val / 255 : val; break;
                    }
                }
                if (isValid) { vertices.push(x, y, z); if (hasColor) colors.push(r, g, b); }
            }
            return { vertices, colors };
        }

        function saveMappingState() { mappingHistory.push([...columnMappings]); DOM.preprocessUndoBtn.disabled = false; }
        function undoMapping() {
            if (mappingHistory.length <= 1) return;
            mappingHistory.pop();
            columnMappings = mappingHistory[mappingHistory.length - 1];
            DOM.columnMappingContainer.querySelectorAll('select').forEach((s, i) => s.value = columnMappings[i]);
            updatePreprocessPreview();
            if (mappingHistory.length <= 1) DOM.preprocessUndoBtn.disabled = true;
        }
        function closePreprocessModal() { DOM.preprocessModal.classList.add('hidden'); DOM.preprocessModal.classList.remove('flex'); originalFileContent = null; currentFileName = null; }

        function applyPreprocessAndVisualize() {
            showProgress("正在应用设置并转换坐标...");
            setTimeout(() => {
                const { vertices, colors } = parseDataWithMappings(originalFileContent, columnMappings);
                const { transformedVertices, transform } = transformToLocalMeters(vertices);
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(transformedVertices, 3));
                if (colors.length > 0) geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: colors.length > 0 });
                if (colors.length === 0) material.color.set(0x00aaff);
                const points = new THREE.Points(geometry, material);
                displayLoadedObject(points, currentFileName, transform);
                hideProgress();
                closePreprocessModal();
            }, 50);
        }

        // 新增：地理坐标转局部米坐标函数
        function transformToLocalMeters(vertices) {
            if (vertices.length === 0) return { transformedVertices: [], transform: null };
            const box = new THREE.Box3();
            const tempVec = new THREE.Vector3();
            for(let i = 0; i < vertices.length; i += 3) {
                tempVec.set(vertices[i], vertices[i+1], vertices[i+2]);
                box.expandByPoint(tempVec);
            }
            const center = new THREE.Vector3();
            box.getCenter(center);

            const R = 6378137; // WGS84 Equatorial Radius in meters
            const metersPerDegreeLat = R * (Math.PI / 180);
            const metersPerDegreeLon = metersPerDegreeLat * Math.cos(center.y * Math.PI / 180);

            const transformedVertices = [];
            for (let i = 0; i < vertices.length; i += 3) {
                transformedVertices.push((vertices[i] - center.x) * metersPerDegreeLon);
                transformedVertices.push((vertices[i + 1] - center.y) * metersPerDegreeLat);
                transformedVertices.push(vertices[i + 2] - center.z);
            }
            
            const transform = { center, metersPerDegree: { lon: metersPerDegreeLon, lat: metersPerDegreeLat } };
            return { transformedVertices, transform };
        }
        
        // --- 文件加载与解析 ---
        function onFileSelected(event) {
            const files = event.target.files; if (!files || files.length === 0) return;
            showProgress("正在准备文件...");
            const fileMap = {};
            for (const file of files) { fileMap[file.name.split('.').pop().toLowerCase()] = file; fileMap[file.name] = file; }
            const objFile = fileMap['obj'], plyFile = fileMap['ply'], txtFile = fileMap['txt'] || fileMap['xyz'];
            if (objFile && !fileMap['mtl']) { objFile.text().then(text => showPreprocessModal(text.split('\n').filter(l => l.startsWith('v ')).map(l => l.substring(2)).join('\n'), objFile.name)); }
            else if (objFile && fileMap['mtl']) { loadOBJWithMaterials(fileMap); }
            else if (plyFile) { plyFile.text().then(text => showPreprocessModal(text, plyFile.name)); }
            else if (txtFile) { txtFile.text().then(text => showPreprocessModal(text, txtFile.name)); }
            else { alert("未找到支持的文件或文件组合。"); hideProgress(); }
            DOM.fileInput.value = '';
        }

        function loadOBJWithMaterials(fileMap) {
            showProgress("正在加载OBJ模型...");
            const objFile = fileMap['obj'], mtlFile = fileMap['mtl'], imageFiles = Object.values(fileMap).filter(f => f.name.match(/\.(jpe?g|png)$/i));
            const manager = new THREE.LoadingManager();
            const fileURLs = [], fileURLMap = {};
            for (const file of Object.values(fileMap)) { const url = URL.createObjectURL(file); fileURLs.push(url); fileURLMap[file.name] = url; }
            manager.onProgress = (url, loaded, total) => updateProgressBar((loaded / total) * 100, `加载中: ${url.split('/').pop()}`);
            manager.onLoad = () => { hideProgress(); fileURLs.forEach(url => URL.revokeObjectURL(url)); };
            manager.onError = (url) => { hideProgress(); fileURLs.forEach(url => URL.revokeObjectURL(url)); alert(`加载资源失败: ${url}`); };
            manager.setURLModifier((url) => {
                const filename = url.split(/[\\/]/).pop();
                if (fileURLMap[filename]) return fileURLMap[filename];
                if (imageFiles.length === 1 && filename.match(/\.(jpe?g|png)$/i)) return fileURLMap[imageFiles[0].name];
                return url;
            });
            const mtlLoader = new MTLLoader(manager), objLoader = new OBJLoader(manager);
            mtlLoader.load(fileURLMap[mtlFile.name], (materials) => {
                materials.preload(); objLoader.setMaterials(materials);
                objLoader.load(fileURLMap[objFile.name], (object) => displayLoadedObject(object, objFile.name));
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(preprocessRenderer) {
                const { width, height } = DOM.preprocessPreviewContainer.getBoundingClientRect();
                preprocessCamera.aspect = width / height;
                preprocessCamera.updateProjectionMatrix();
                preprocessRenderer.setSize(width, height);
            }
        }
        function onCanvasClick(event) {
            if (interactionMode !== 'picking' || !currentObject) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentObject, true);
            if (intersects.length > 0) {
                const i = intersects[0];
                const localPosition = i.point.clone();
                const originalPosition = i.point.clone();
                if (i.object.userData.transform) {
                    const { center, metersPerDegree } = i.object.userData.transform;
                    originalPosition.x = (localPosition.x / metersPerDegree.lon) + center.x;
                    originalPosition.y = (localPosition.y / metersPerDegree.lat) + center.y;
                    originalPosition.z = localPosition.z + center.z;
                }
                pickedPointMarker.position.copy(localPosition);
                pickedPointMarker.visible = true;
                let colorInfo = "N/A";
                if (i.object.isPoints) {
                    const geom = i.object.geometry;
                    if (geom.attributes.color && i.index !== undefined) {
                        const c = new THREE.Color().fromBufferAttribute(geom.attributes.color, i.index);
                        colorInfo = `R: ${Math.floor(c.r*255)}, G: ${Math.floor(c.g*255)}, B: ${Math.floor(c.b*255)}`;
                    }
                } else if (i.object.isMesh) {
                    const mat = i.object.material;
                    if (mat.map && i.uv) {
                        const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d', { willReadFrequently: true });
                        const img = mat.map.image;
                        canvas.width = img.width; canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        const d = ctx.getImageData(Math.floor(i.uv.x * img.width), Math.floor((1 - i.uv.y) * img.height), 1, 1).data;
                        colorInfo = `R: ${d[0]}, G: ${d[1]}, B: ${d[2]}`;
                    } else if (mat.color) {
                        colorInfo = `R: ${Math.floor(mat.color.r*255)}, G: ${Math.floor(mat.color.g*255)}, B: ${Math.floor(mat.color.b*255)}`;
                    }
                }
                DOM.pickingData.innerHTML = `
                    <p class="font-semibold text-white">真实世界坐标:</p>
                    <p>经度: ${originalPosition.x.toFixed(8)}</p>
                    <p>纬度: ${originalPosition.y.toFixed(8)}</p>
                    <p>高程: ${originalPosition.z.toFixed(3)} m</p>
                    <p class="font-semibold text-white mt-2">局部坐标 (米):</p>
                    <p>X: ${localPosition.x.toFixed(3)} m</p>
                    <p>Y: ${localPosition.y.toFixed(3)} m</p>
                    <p>Z: ${localPosition.z.toFixed(3)} m</p>
                    <p class="font-semibold text-white mt-2">颜色 (R,G,B):</p>
                    <p>${colorInfo}</p>`;
                DOM.pickingInfoPanel.classList.remove('hidden');
            } else {
                pickedPointMarker.visible = false;
                DOM.pickingInfoPanel.classList.add('hidden');
            }
        }
        function generateSamplePointCloud() {
            const vertices = [];
            for (let i = 0; i < 50000; i++) {
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                vertices.push(8 * Math.sin(phi) * Math.cos(theta), 8 * Math.sin(phi) * Math.sin(theta), 8 * Math.cos(phi));
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.05, color: 0x00aaff }));
            displayLoadedObject(points, "默认示例点云 (球体)");
        }

        // --- 初始化 ---
        function init() {
            // 主场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(10, 10, 10);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            DOM.container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.AxesHelper(10));
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.1;
            mouse = new THREE.Vector2();
            pickedPointMarker = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
            pickedPointMarker.visible = false;
            scene.add(pickedPointMarker);
            
            setupEventListeners();
            generateSamplePointCloud();
            animateMainScene();
        }

        // --- 事件监听 ---
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            DOM.fileInput.addEventListener('change', onFileSelected);
            DOM.pointSizeSlider.addEventListener('input', handlePointSizeChange);
            DOM.opacitySlider.addEventListener('input', handleOpacityChange);
            DOM.bgDarkBtn.addEventListener('click', () => setBackgroundTheme('dark'));
            DOM.bgLightBtn.addEventListener('click', () => setBackgroundTheme('light'));
            DOM.closeModelBtn.addEventListener('click', closeCurrentModel);
            DOM.modePointerBtn.addEventListener('click', () => setInteractionMode('picking'));
            DOM.modeHandBtn.addEventListener('click', () => setInteractionMode('navigation'));
            DOM.preprocessUndoBtn.addEventListener('click', undoMapping);
            DOM.preprocessCloseBtn.addEventListener('click', closePreprocessModal);
            DOM.preprocessApplyBtn.addEventListener('click', applyPreprocessAndVisualize);
            renderer.domElement.addEventListener('click', onCanvasClick);
        }

        init();
    </script>
</body>
</html>
